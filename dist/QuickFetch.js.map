{"version":3,"file":"QuickFetch.js","sources":["../src/utils.ts","../src/MiddlewareHolder.ts","../src/CustomError.ts","../src/OptRequest.ts","../src/index.ts"],"sourcesContent":["import qs from \"qs\";\nimport OptRequest from \"./OptRequest\";\nimport { QFHeaders, QFOption, QFCloneable } from \"./quickfetch\";\n\nexport function _getLatestHeaders(request: OptRequest): QFHeaders {\n  const newHeaders: QFHeaders = {};\n  for (const key of request.headers.keys()) {\n    newHeaders[key] = request.headers.get(key);\n  }\n  return newHeaders;\n}\n\nexport function _cloneObject(target: QFCloneable) {\n  return target && \"clone\" in target && typeof target.clone === \"function\"\n    ? target.clone()\n    : target;\n}\n\nlet _fid = 0;\nexport function _getDefaultFetchId() {\n  return Symbol.for(`default_fetchId_${_fid++}`);\n}\n\nexport function _isValidFetchId(fetchId?: string | number | symbol) {\n  return (\n    typeof fetchId !== \"undefined\" &&\n    (typeof fetchId === \"number\" ||\n      (typeof fetchId === \"string\" && fetchId.length) ||\n      (typeof fetchId === \"symbol\" &&\n        !/^default_fetchId_/.test(Symbol.keyFor(fetchId)!)))\n  );\n}\n\nexport function _formatHeaders(option: QFOption) {\n  if (option?.headers) {\n    Object.keys(option.headers).forEach((key) => {\n      let hVal = option.headers[key];\n      // case-sensitive\n      delete option.headers[key];\n      key = key.toLowerCase();\n      option.headers[key] = hVal;\n      // clear\n      if (typeof hVal === \"undefined\" || hVal === null || hVal === \"\") {\n        delete option.headers[key];\n      }\n    });\n  }\n}\n\nexport function _parseBody(\n  option: QFOption,\n  method: string,\n  params: any\n): void {\n  if (!option) return;\n\n  delete option.body;\n\n  const needBody = !~option.ignoreBodyMethods!.indexOf(method.toLowerCase());\n  const sendJSON =\n    option.forceJSON ||\n    (option.headers &&\n      /^application\\/(.*?\\+)?json;?/.test(option.headers[\"content-type\"]));\n  if (needBody) {\n    option.body = sendJSON ? JSON.stringify(params) : qs.stringify(params);\n  }\n}\n\nexport function _getURL(option: QFOption, url: string, params: any): string {\n  if (!option) return url;\n  let rUrl = url;\n  if (!option.body) {\n    const strParam = qs.stringify(params);\n    if (strParam.length) {\n      const divSign = ~rUrl.indexOf(\"?\") ? \"&\" : \"?\";\n      rUrl += divSign + strParam;\n    }\n  }\n  // url prefix\n  if (option.baseURL) {\n    rUrl = `${option.baseURL}/${rUrl}`.replace(/\\/+/g, \"/\");\n  }\n  // endpoint\n  if (option.endpoint) {\n    rUrl = `${option.endpoint}${rUrl}`;\n  }\n  return rUrl;\n}\n","import findIndex from \"lodash-es/findIndex\";\nimport { _cloneObject, _isValidFetchId } from \"./utils\";\nimport {\n  QFMidWrapper,\n  QFMidFn,\n  QFMidTypes,\n  QFOption,\n  QFCloneable,\n  QFFetchID,\n  QFUseReturnType,\n} from \"./quickfetch\";\n\n/**\n * MiddlewareHolder\n * @extends EventTarget\n */\nclass MiddlewareHolder extends EventTarget {\n  private _midIdFlag: number;\n  private _mids: Array<QFMidWrapper>;\n\n  constructor() {\n    super();\n    this._midIdFlag = 0;\n    this._mids = [];\n  }\n\n  /**\n   * @protected\n   * @param {String} type - QuickFetch.REQUEST | QuickFetch.RESPONSE | QuickFetch.ERROR\n   * @param {Object} [option]\n   */\n  protected _getMiddlewares(\n    type: QFMidTypes,\n    option: QFOption\n  ): Array<QFMidFn> {\n    const mObjArr = this._mids.filter((m) => m.type === type);\n    if (!mObjArr.length) return [];\n    let mids = mObjArr;\n    const fetchId = option?.fetchId;\n    if (_isValidFetchId(fetchId)) {\n      mids = mids.filter((mw) => !mw.fetchId || mw.fetchId === fetchId);\n      mids = mids.filter((mw) => !mw.disabledUses[fetchId!]);\n      if (!mids.length) return [];\n    } else {\n      mids = mObjArr.filter((mw) => !mw.fetchId);\n      mids = mids.filter((mw) => !mw.allDisabled);\n    }\n    return mids.map((mw) => mw.middleware);\n  }\n\n  /**\n   * @protected\n   * @param {Array} mids\n   * @param {Request|Response|JSON|Blob} target\n   * @param {Object} [params = null]\n   */\n  protected _parseMiddlewares(\n    mids: Array<QFMidFn>,\n    target: QFCloneable,\n    params: any = null\n  ) {\n    if (!mids) {\n      return Promise.resolve(_cloneObject(target));\n    }\n    // eslint-disable-next-line no-unused-vars\n    return new Promise((resolve) => {\n      const next = (obj: QFCloneable) => {\n        const rtn = _cloneObject(obj);\n        if (params) {\n          Object.keys(params).forEach((k) => ((rtn as any)[k] = params[k]));\n        }\n        if (!mids.length) {\n          return resolve(rtn);\n        }\n        const mw = mids.shift();\n        mw?.(rtn, next);\n      };\n      next(_cloneObject(target));\n    });\n  }\n\n  /**\n   * regist a middleware\n   * @param {string} type - QuickFetch.REQUEST | QuickFetch.RESPONSE | QuickFetch.ERROR\n   * @param {function} middleware - a function looks like ```(req|res|err, next) => {}```\n   * @param {string|number} [fetchId] - a optional id for special requests\n   * @returns {object} actions - { unuse, pause, resume }\n   */\n  use(\n    type: QFMidTypes,\n    middleware: QFMidFn,\n    fetchId: QFFetchID\n  ): QFUseReturnType {\n    if (!type || typeof type !== \"string\") return;\n    if (!middleware || typeof middleware !== \"function\") return;\n\n    const id = this._midIdFlag++;\n\n    const mObj: QFMidWrapper = {\n      id,\n      type,\n      middleware,\n      disabledUses: {},\n    };\n\n    if (_isValidFetchId(fetchId)) {\n      mObj.fetchId = fetchId;\n    }\n\n    this._mids.push(mObj);\n\n    console.log(\n      \"regist middleware %s %s, new array length is %s\",\n      id,\n      _isValidFetchId(fetchId) ? `(${fetchId.toString()})` : \"\",\n      this._mids.length\n    );\n\n    return {\n      unuse: () => this._unuse(id),\n      pause: (muId) => this._pause(id, muId),\n      resume: (muId) => this._resume(id, muId),\n    };\n  }\n\n  /**\n   * @protected\n   * unregist a middleware\n   * @param {number} id\n   */\n  protected _unuse(id: number): void {\n    if (typeof id === \"undefined\") return;\n    const idx = findIndex(this._mids, { id });\n    if (idx < 0) return;\n    this._mids.splice(idx, 1);\n\n    console.log(\n      `unregist middleware ${id}, new array length is ${this._mids.length}`\n    );\n  }\n\n  /**\n   * @protected\n   * pause a middleware\n   * @param {number} id\n   * @param {string|number} [fetchId] - a optional id for special requests\n   */\n  protected _pause(id: number, fetchId: QFFetchID): void {\n    if (typeof id === \"undefined\") return;\n    const idx = findIndex(this._mids, { id });\n    if (idx < 0) return;\n\n    const mw = this._mids[idx];\n    const dObj = mw.disabledUses;\n\n    if (_isValidFetchId(fetchId) && !dObj[fetchId]) {\n      dObj[fetchId] = true;\n    } else {\n      mw.allDisabled = true;\n    }\n\n    console.log(\n      `pause(disable) middleware ${id} ${\n        _isValidFetchId(fetchId) ? \"for \" + fetchId.toString() : \"\"\n      }`,\n      dObj\n    );\n  }\n\n  /**\n   * @protected\n   * resume a paused middleware\n   * @param {number} id\n   * @param {string|number} [fetchId] - a optional id for special requests\n   */\n  protected _resume(id: number, fetchId: QFFetchID): void {\n    if (typeof id === \"undefined\") return;\n    const idx = findIndex(this._mids, { id });\n    if (idx < 0) return;\n\n    const mw = this._mids[idx];\n    const dObj = mw.disabledUses;\n\n    if (_isValidFetchId(fetchId) && dObj[fetchId]) {\n      delete dObj[fetchId];\n    } else {\n      mw.allDisabled = false;\n    }\n\n    console.log(\n      `resume(enable) middleware ${id} ${\n        _isValidFetchId(fetchId) ? \"for \" + fetchId.toString() : \"\"\n      }`,\n      dObj\n    );\n  }\n}\n\nexport default MiddlewareHolder;\n","class CustomError extends Error {\n  data: any;\n  constructor(message: string, data: any) {\n    super(message);\n    this.data = data;\n  }\n}\n\nexport default CustomError;\n","import { _getLatestHeaders } from \"./utils\";\nimport { QFOption } from \"./quickfetch\";\n\nclass OptRequest extends Request {\n  init: QFOption;\n  constructor(req: string | Request, init: QFOption) {\n    super(req, init as any);\n    this.init = init;\n  }\n  clone() {\n    if (this.init) {\n      this.init.headers = _getLatestHeaders(this);\n    }\n    return new OptRequest(super.clone(), this.init);\n  }\n}\n\nexport default OptRequest;\n","import clone from \"lodash-es/clone\";\nimport mergeWith from \"lodash-es/mergeWith\";\nimport uniq from \"lodash-es/uniq\";\nimport trim from \"lodash-es/trim\";\nimport isEmpty from \"lodash-es/isEmpty\";\nimport MiddlewareHolder from \"./MiddlewareHolder\";\nimport CustomError from \"./CustomError\";\nimport OptRequest from \"./OptRequest\";\nimport {\n  _getLatestHeaders,\n  _formatHeaders,\n  _parseBody,\n  _getURL,\n  _getDefaultFetchId,\n} from \"./utils\";\nimport { QFFetchID, QFOption, QFDoReqFn } from \"./quickfetch\";\n\n// @ts-ignore\nconst _abortControllers: { [key: QFFetchID]: AbortController } = {};\nconst supportsAbort = typeof AbortController === \"function\";\n\n/**\n * an optional object for Request API\n * @typedef {Object|Null} option\n * @property {string} [method] standard fetch init option\n * @property {string} [credentials = include] standard fetch init option\n * @property {string} [mode = cors] standard fetch init option\n * @property {string} [cache = reload] standard fetch init option\n * @property {Object} [headers] standard fetch init option\n * @property {string} [endpoint] - optional, e.g. http://xxx.com:8090\n * @property {string} [baseURL] - optional, an url prefix, e.g. /myapi\n * @property {string} [timeout     = 30000] - optional, timeout\n * @property {boolean} [catchError = true] - optional,\n *  if true then just parse error in middleware, otherwise throw it to endpoint\n * @property {Array} [ignoreBodyMethods = ['get', 'head']] optional\n * @property {boolean} [forceJSON = false] optional, send body with JSON.stringify()\n * @property {string|number|symbol} [fetchId] optional, an unique ID of every fetch request\n * @property {AbortSignal} [signal] optional, a given signal to cancel the fetch request\n */\n\n/**\n * QuickFetch\n * @extends MiddlewareHolder\n */\nexport default class QuickFetch extends MiddlewareHolder {\n  /**\n   * @memberof QuickFetch\n   * @static\n   */\n  static readonly REQUEST: string = \"REQUESTER_TYPE_REQUEST\";\n  /**\n   * @memberof QuickFetch\n   * @static\n   */\n  static readonly RESPONSE: string = \"REQUESTER_TYPE_RESPONSE\";\n  /**\n   * @memberof QuickFetch\n   * @static\n   */\n  static readonly ERROR: string = \"REQUESTER_TYPE_ERROR\";\n  /**\n   * @memberof QuickFetch\n   * @static\n   */\n  static readonly EXCEPTION_TIMEOUT: string = \"REQUESTER_ERROR_TIMEOUT\";\n  /**\n   * @memberof QuickFetch\n   * @static\n   */\n  static readonly EVENT_FETCH_ABORT: string = \"FetchAbort\";\n  /**\n   * cancel a fetch action\n   * @static\n   * @param {string|number|symbol} id - fetchId\n   */\n  static abort(id: QFFetchID) {\n    if (!supportsAbort) return;\n    // @ts-ignore\n    const ac: AbortController = _abortControllers[id];\n    if (!ac) return;\n    if (ac instanceof AbortController) {\n      // console.log(id, 'abort');\n      ac.abort();\n    }\n    // @ts-ignore\n    delete _abortControllers[id];\n  }\n\n  private _globalOption: QFOption;\n  private _originFetch: (...args: any[]) => any;\n\n  /**\n   * QuickFetch constructor\n   * @description a fetch-based HTTP request tool\n   * @class\n   * @param {option} [option]\n   */\n  constructor(option: QFOption) {\n    super();\n    this._globalOption = option;\n    this._originFetch = fetch;\n  }\n\n  /**\n   * @private\n   * @param {OptRequest} req\n   * @param {object} [option]\n   */\n  private _parseRequestMiddlewares(req: OptRequest, option: QFOption) {\n    const reqMids = this._getMiddlewares(QuickFetch.REQUEST, option);\n    return this._parseMiddlewares(reqMids, req);\n  }\n\n  /**\n   * @private\n   * @param {Response} res\n   * @param {object} [option]\n   */\n  private _parseResponseMiddlewares(res: OptRequest, option: QFOption) {\n    const resMids = this._getMiddlewares(QuickFetch.RESPONSE, option);\n    const parseParams = {\n      method: option!.method.toUpperCase(),\n    };\n    if (!isEmpty(option!.headers)) {\n      try {\n        // @ts-ignore\n        parseParams.requestHeaders = new Headers(option.headers);\n      } catch (ex) {}\n    }\n    return this._parseMiddlewares(resMids, res, parseParams);\n  }\n\n  /**\n   * @private\n   * @param {Error} err\n   * @param {object} [option]\n   */\n  private _parseErrorMiddlewares(err: Error, option: QFOption) {\n    const errMids = this._getMiddlewares(QuickFetch.ERROR, option);\n    return this._parseMiddlewares(errMids, err);\n  }\n\n  /**\n   * @private\n   * @param {string} method - a HTTP verb\n   * @param {function} a function to execute the real HTTP verb\n   */\n  private _doRequest(method: string = \"get\"): QFDoReqFn {\n    method = method.toUpperCase();\n\n    // the origin fetch method\n    let _fetch = this._originFetch;\n    let _this = this;\n\n    return function (url, params = {}, originOption = {}) {\n      // merge option\n      const option: QFOption = [\n        {\n          method,\n          credentials: \"include\",\n          mode: \"cors\",\n          cache: \"reload\",\n          headers: {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\",\n          },\n          ignoreBodyMethods: [\"get\", \"head\"],\n          forceJSON: false,\n          timeout: 30000,\n          baseURL: \"\",\n          catchError: true,\n          fetchId: _getDefaultFetchId(),\n        },\n        this._globalOption,\n        originOption,\n      ].reduce((rst, opt) => {\n        rst = mergeWith(\n          rst,\n          opt,\n          // @ts-ignore\n          (objValue, srcValue, key, object, source, stack) => {\n            if (key === \"ignoreBodyMethods\") {\n              return uniq(\n                (Array.isArray(srcValue) ? srcValue : []).concat([\n                  \"get\",\n                  \"head\",\n                ]) // ensure GET/HEAD\n              );\n            }\n            if (Array.isArray(objValue) && Array.isArray(srcValue)) {\n              return srcValue; // 合并数组时直接替换\n            }\n            return void 0; // 默认合并\n          }\n        );\n        return rst;\n      }, {}) as QFOption;\n\n      if (supportsAbort) {\n        const _ac = new AbortController();\n        if (!option!.signal) option!.signal = _ac.signal;\n        // @ts-ignore\n        _abortControllers[option!.fetchId] = _ac;\n        option!.signal.addEventListener(\"abort\", () => {\n          const evt = new CustomEvent(QuickFetch.EVENT_FETCH_ABORT, {\n            detail: {\n              fetchId: option!.fetchId,\n              signal: option!.signal,\n            },\n          });\n          _this.dispatchEvent(evt);\n        });\n      }\n\n      _formatHeaders(option);\n      _parseBody(option, method, params);\n      let rUrl = _getURL(option, url, params);\n      const req = new OptRequest(trim(rUrl), option);\n\n      // timeout support\n      if (option && \"timeout\" in option) {\n        if (typeof option.timeout === \"string\") {\n          option.timeout = parseInt(option.timeout, 10);\n        }\n        if (!!option.timeout) {\n          _fetch = ((fetch) => {\n            return (...toargs: any[]) => {\n              const fetchPromise = fetch.apply(null, toargs);\n              // eslint-disable-next-line no-unused-vars\n              const timeoutPromise = new Promise((_, reject) => {\n                const err = new CustomError(\n                  QuickFetch.EXCEPTION_TIMEOUT,\n                  toargs[0]\n                );\n                setTimeout(() => {\n                  reject(err);\n                }, option.timeout);\n              });\n              return Promise.race([fetchPromise, timeoutPromise]);\n            };\n          })(this._originFetch);\n        }\n      }\n\n      return (\n        this._parseRequestMiddlewares(req, option)\n          // @ts-ignore\n          .then((request: OptRequest) => {\n            let optClone = clone(request.init) as QFOption;\n            optClone!.headers = _getLatestHeaders(request);\n\n            _formatHeaders(optClone);\n            _parseBody(optClone, method, params);\n            let rUrl = _getURL(optClone, url, params);\n            const reqClone = new OptRequest(rUrl, optClone);\n\n            return _fetch(reqClone)\n              .then((res: OptRequest) =>\n                this._parseResponseMiddlewares(res, option)\n              )\n              .catch((error: Error) => {\n                (error as any).request = req.clone();\n                return this._parseErrorMiddlewares(error, option);\n              });\n          })\n          .then((obj) => {\n            if (obj && obj instanceof Error && option!.catchError) {\n              throw obj;\n            }\n            return obj;\n          })\n          .catch((err) => {\n            if (err && option!.catchError) {\n              throw err;\n            }\n          })\n      );\n    };\n  }\n\n  /**\n   * make a GET fetch\n   * @param {string} url\n   * @param {Object|null} [params] - an optional params object\n   * @param {option} [option]\n   * @see {@link QuickFetch#constuctor}\n   * @returns {Promise} a Promise that resolves to a Response object\n   */\n  get(...args: keyof QFDoReqFn) {\n    return this._doRequest(\"get\").apply(this, args);\n  }\n\n  /**\n   * make a POST fetch\n   * @param {string} url\n   * @param {Object|null} [params] - an optional params object\n   * @param {option} [option]\n   * @returns {Promise} a Promise that resolves to a Response object\n   */\n  post(...args: keyof QFDoReqFn) {\n    return this._doRequest(\"post\").apply(this, args);\n  }\n\n  /**\n   * make a DELETE fetch\n   * @param {string} url\n   * @param {Object|null} [params] - an optional params object\n   * @param {option} [option]\n   * @returns {Promise} a Promise that resolves to a Response object\n   */\n  delete(...args: keyof QFDoReqFn) {\n    return this._doRequest(\"delete\").apply(this, args);\n  }\n\n  /**\n   * make a PUT fetch\n   * @param {string} url\n   * @param {Object|null} [params] - an optional params object\n   * @param {option} [option]\n   * @returns {Promise} a Promise that resolves to a Response object\n   */\n  put(...args: keyof QFDoReqFn) {\n    return this._doRequest(\"put\").apply(this, args);\n  }\n\n  /**\n   * make a PATCH fetch\n   * @param {string} url\n   * @param {Object|null} [params] - an optional params object\n   * @param {option} [option]\n   * @returns {Promise} a Promise that resolves to a Response object\n   */\n  patch(...args: keyof QFDoReqFn) {\n    return this._doRequest(\"patch\").apply(this, args);\n  }\n\n  /**\n   * make batch requests\n   * @param {Promise[]} requestPromiseArr\n   * @returns {Response[]}\n   */\n  sequence(requestPromiseArr: Array<Promise<any>>) {\n    const responseArr: Array<Promise<any>> = [];\n    return requestPromiseArr\n      .reduce(\n        (promise, req) =>\n          promise.then(() =>\n            req\n              .then((res) => responseArr.push(res))\n              .catch((ex) => Promise.reject(ex))\n          ),\n        Promise.resolve()\n      )\n      .then(() => responseArr);\n  }\n}\n\n"],"names":["_getLatestHeaders","request","newHeaders","headers","keys","key","get","_cloneObject","target","clone","_fid","_isValidFetchId","fetchId","length","test","Symbol","keyFor","_formatHeaders","option","Object","forEach","hVal","toLowerCase","_parseBody","method","params","body","needBody","ignoreBodyMethods","indexOf","sendJSON","forceJSON","JSON","stringify","qs","_getURL","url","rUrl","strParam","divSign","baseURL","replace","endpoint","MiddlewareHolder","_this","_midIdFlag","_mids","_getMiddlewares","type","mObjArr","this","filter","m","mids","mw","disabledUses","allDisabled","map","middleware","_parseMiddlewares","Promise","resolve","next","obj","rtn","k","shift","use","id","mObj","push","console","log","toString","unuse","_this2","_unuse","pause","muId","_pause","resume","_resume","idx","findIndex","splice","dObj","EventTarget","CustomError","message","data","Error","OptRequest","req","init","Request","_abortControllers","supportsAbort","AbortController","QuickFetch","_globalOption","_originFetch","fetch","abort","ac","_parseRequestMiddlewares","reqMids","REQUEST","_parseResponseMiddlewares","res","resMids","RESPONSE","parseParams","toUpperCase","isEmpty","requestHeaders","Headers","ex","_parseErrorMiddlewares","err","errMids","ERROR","_doRequest","_fetch","originOption","credentials","mode","cache","Accept","Content-Type","timeout","catchError","for","reduce","rst","opt","mergeWith","objValue","srcValue","object","source","stack","uniq","Array","isArray","concat","_ac","signal","addEventListener","evt","CustomEvent","EVENT_FETCH_ABORT","detail","dispatchEvent","trim","parseInt","toargs","fetchPromise","apply","timeoutPromise","_","reject","EXCEPTION_TIMEOUT","setTimeout","race","then","optClone","reqClone","_this3","catch","error","post","delete","put","patch","sequence","requestPromiseArr","responseArr","promise"],"mappings":"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"}